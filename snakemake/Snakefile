import os
from pathlib import Path
configfile: "config.yaml"

def return_barcode_numbers(path: str):
    """
    This function will return a list of barcode numbers under the directory passed in
    Args:
        path: The directory that should be searched
    Returns: A list of strings containing directory names
    """
    barcode_numbers = set()
    for item in os.scandir(path):
        item = item.name
        if "barcode" in item:
            barcode_numbers.add(item)
        elif "unclassified" in item:
            barcode_numbers.add(item)
    return barcode_numbers
def barcode_merge_files(wildcards):
    basecall_checkpoint = checkpoints.basecall.get(**wildcards).output[0]
    barcode_checkpoint = checkpoints.barcode.get(**wildcards).output[0]
    barcodes = set()  # a set is like a list, but only stores unique values
    for folder in os.listdir(barcode_checkpoint):
        full_path = os.path.join(barcode_checkpoint, folder)
        if Path(full_path).is_dir():
            barcodes.add(folder)

    merge_files = [config['results_folder'] + "Barcode/" + barcode + ".merged.fastq" for barcode in barcodes]
    return merge_files
def nanoqc_basecall_data(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/NanoQC/BasecallData/"
def nanoqc_barcode_classified(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/NanoQC/BarcodeData/classified"
def nanoqc_barcode_unclassified(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/NanoQC/BarcodeData/unclassified"
def cutadapt(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return expand(
        config['results_folder'] + "Cutadapt/{barcode}.cutadapt.fastq",
        barcode=return_barcode_numbers(checkpoint_output))
def filtering(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return expand(
        config['results_folder'] + "Filtering/{barcode}.nanofilt.fastq",
        barcode=return_barcode_numbers(checkpoint_output))
def guppy_aligner(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return expand(
        config['results_folder'] + "Alignment/guppy/sam_files/{barcode}.guppy.sam",
               barcode=return_barcode_numbers(checkpoint_output))
def minimap_aligner(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return expand(
        config['results_folder'] + "Alignment/minimap/{barcode}.minimap.sam",
        barcode=return_barcode_numbers(checkpoint_output))
def vsearch_aligner(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return expand(
        config['results_folder'] + "Alignment/vsearch/{barcode}.vsearch.uc",
        barcode=return_barcode_numbers(checkpoint_output))
def nanoplot(wildcards):
    checkpoint_output = checkpoints.basecall.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/NanoPlot/Basecall/"
def count_reads_basecall(wildcards):
    checkpoint_output = checkpoints.basecall.get(**wildcards).output[0]
    return config['results_folder'] + "CountReads/count.reads.basecall.csv"
def count_reads_barcode(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "CountReads/count.reads.barcode.csv"
def count_reads_trim(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "CountReads/count.reads.cutadapt.csv"
def count_reads_nanofilt(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "CountReads/count.reads.nanofilt.csv"
def count_reads_guppy(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "CountReads/count.reads.guppy.csv"
def plotly_histogram_barcode(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/Plotly/Histograms/plotly.barcode.histogram.html"
def plotly_histogram_cutadapt(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/Plotly/Histograms/plotly.cutadapt.histogram.html"
def plotly_histogram_filtering(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/Plotly/Histograms/plotly.filtering.histogram.html"
def plotly_histogram_mapping(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/Plotly/Histograms/plotly.mapping.histogram.html"
def plotly_box_whisker(wildcards):
    checkpoint_output = checkpoints.barcode.get(**wildcards).output[0]
    return config['results_folder'] + "Visuals/Plotly/plotly.box.whisker.html"
FAST5_FILES = glob_wildcards(config['fast5_location'] + "{fast5_file}.fast5").fast5_file



rule all:
    input:
        barcode_merge_files,  #......................................... Basecall, barcode, and merge files in a checkpoint
         # nanoqc_basecall_data,  #....................................... NanoQC after basecall
         # nanoqc_barcode_classified,  #.................................. NanoQC classified barcodes
         # nanoqc_barcode_unclassified,  #................................ NanoQC unclassified barcodes
         cutadapt,  #................................................... Trim (Cutadapt)
         filtering,  #................................................... NanoFilt
         guppy_aligner,  #.............................................. Guppy Aligner
         minimap_aligner,  #............................................ MiniMap Aligner
         vsearch_aligner,  #............................................ VSearch Aligner
         count_reads_basecall,  #....................................... Count reads after basecall
         count_reads_barcode,  #........................................ Count reads after barcode (and merge files)
         count_reads_trim,  #........................................... Count reads after trimming
         count_reads_nanofilt,  #....................................... Count reads after NanoFilt
         count_reads_guppy,  #.......................................... Count reads after guppy aligner
         nanoplot,  #................................................... NanoPlot
         plotly_histogram_barcode,  #................................... Plotly barcode histogram
         plotly_histogram_cutadapt,  #.................................. Plotly cutadapt histogram
         plotly_histogram_filtering,  #................................. Plotly filtering histogram
         plotly_histogram_mapping,  #................................... Plotly mapping histogram
         plotly_box_whisker  #.......................................... Plotly box and whisker plot



checkpoint basecall:
    input:
        config['fast5_location']
    output:
        output = directory(config['results_folder'] + "Basecall/")
    params:
        configuration = config["basecall_configuration"],
        callers = config['num_callers'],
        threads_per_caller = config['num_threads_per_caller']
    shell:
        r"""
        echo Basecalling
        guppy_basecaller \
        --config {params.configuration} \
        --input_path {input} \
        --save_path {output} \
        --num_callers {params.callers} \
        --cpu_threads_per_caller {params.threads_per_caller} \
        --recursive \
        --quiet
        """



checkpoint barcode:
    input:
        rules.basecall.output[0]
    output:
        directory(config['results_folder'] + ".temp/barcodeTempOutput/")
    params:
        barcode_kit = config['barcode_kit']
    shell:
        r"""
        echo Barcoding
        guppy_barcoder \
        -i {input} \
        -s {output} \
        --barcode_kits {params.barcode_kit} \
        --recursive \
        --quiet        
        """



def merge_files_input(wildcards):
    import glob
    return glob.glob(config['results_folder'] + f".temp/barcodeTempOutput/{wildcards.barcode}/*.fastq")
checkpoint merge_files:
    input:
        merge_files_input
    output:
        config['results_folder'] + "Barcode/{barcode}.merged.fastq"
    params:
        input_folder = config['results_folder'] + ".barcodeTempOutput",
        save_folder = config['results_folder'] + "Barcode"
    shell:
        r"""
        for item in {input}; do
            cat $item >> {output}
        done
        """


rule fq2gzBasecall:
    input:
        rules.basecall.output[0]
    output:
        temp(config['results_folder'] + ".temp/basecall.compressed.reads.fastq.tar.bz2")
    shell:
        r"""
        # create a file (c), using gzip (z), in our specified format (f)
        # give our output location (output) and the input files we are compressing
        tar -cjf {output} {input}*.fastq
        """
rule fq2gzBarcode:
    input:
        expand(config['results_folder'] + "Barcode/{barcode}.merged.fastq",
               barcode=glob_wildcards(config['results_folder'] + "Barcode/{barcode}.merged.fastq").barcode)
    output:
        classified = temp(config['results_folder'] + ".temp/barcode.classified.compressed.reads.fastq.tar.bz2"),
        unclassified = temp(config['results_folder'] + ".temp/barcode.unclassified.compressed.reads.fastq.tar.bz2")
    shell:
        r"""
        # create two arrays, one for classified reads and one for unclassified
        declare -a classified_reads
        declare -a unclassified_reads
        
        # iterate through our input and place each file path into the appropriate array
        for file_path in {input}; do
            if [[ "$file_path" == *"barcode"* ]]; then
                classified_reads+=($file_path)
            elif [[ "$file_path" == *"unclassified"* ]]; then
                unclassified_reads+=($file_path)
            fi
        done
        
        # create a .tgz of our classified and unclassified reads
        tar cfj {output.classified} "${{classified_reads[@]}}"
        tar cfj {output.unclassified} "${{unclassified_reads[@]}}" 
        """

rule NanoQCBasecall:
    input:
        rules.fq2gzBasecall.output[0]
    output:
        directory(config['results_folder'] + "Visuals/NanoQC/BasecallData/")
    shell:
        r"""
        nanoQC -o {output} {input}
        """
rule NanoQCBarcode:
    input:
        classified = rules.fq2gzBarcode.output.classified,
        unclassified = rules.fq2gzBarcode.output.unclassified
    output:
        classified = directory(config['results_folder'] + "Visuals/NanoQC/BarcodeData/classified"),
        unclassified = directory(config['results_folder'] + "Visuals/NanoQC/BarcodeData/unclassified")
    shell:
        r"""
        nanoQC -o {output.classified} {input.classified}
        nanoQ -o {output.unclassified} {input.unclassified}
        """



rule NanoPlotBasecall:
    input:
        expand(config['results_folder'] + "Basecall/{fastq_file}.fastq",
               fastq_file=glob_wildcards(config['results_folder'] + "Basecall/{fastq_file}.fastq").fastq_file)
    output:
        directory(config['results_folder'] + "Visuals/NanoPlot/Basecall/")
    shell:
        r"""
        NanoPlot --fastq {input} -o {output}
        """
rule NanoPlotBarcode:
    input:
        expand(config['results_folder'] + "Barcode/{barcode}.merged.fastq",
               barcode=glob_wildcards(config['results_folder'] + "Barcode/{barcode}.merged.fastq").barcode)
    output:
        classified = directory(config['results_folder'] + "Visuals/NanoPlot/Barcode/classified"),
        unclassified = directory(config['results_folder'] + "Visuals/NanoPlot/Barcode/unclassified")
    shell:
        r"""
        # create two arrays, one for classified reads and one for unclassified
        declare -a classified_reads
        declare -a unclassified_reads
        
        # iterate through our input and place each file path into the appropriate array
        for file_path in {input}; do
            if [[ "$file_path" == *"barcode"* ]]; then
                classified_reads+=($file_path)
            elif [[ "$file_path" == *"unclassified"* ]]; then
                unclassified_reads+=($file_path)
            fi
        done
        
        # run NanoPlot on classified reads
        NanoPlot --fastq "${{classified_reads[@]}}" -o {output.classified}
        
        # run NanoPlot on unclassified reads
        NanoPlot --fastq "${{unclassified_reads[@]}}" -o {output.unclassified}
        """


rule cutadapt:
    input:
        rules.merge_files.output[0]
    output:
        config['results_folder'] + "Cutadapt/{barcode}.cutadapt.fastq"
    params:
        three_prime_adapter = config['trim_three_prime_adapter'],
        five_prime_adapter = config['trim_five_prime_adapter'],
        error_rate = config['trim_error_rate']
    shell:
        r"""
        cutadapt \
        --revcomp \
        --quiet \
        --cores 0 \
        --adapter {params.three_prime_adapter} \
        --front {params.five_prime_adapter} \
        --error-rate {params.error_rate} \
        --output {output} \
        {input}
        """



rule filtering:
    input:
        rules.cutadapt.output[0]
    output:
        config['results_folder'] + "Filtering/{barcode}.nanofilt.fastq"
    shell:
        r"""
        touch {output}
        NanoFilt {input} > {output}
        """



rule guppy_aligner:
    input:
        rules.filtering.output[0]
    output:
        sam_files = config['results_folder'] + "Alignment/guppy/sam_files/{barcode}.guppy.sam",
        alignment_summary = config['results_folder'] + "Alignment/guppy/alignment_summary/{barcode}.alignment.summary.csv",
        log_file = config['results_folder'] + "Alignment/guppy/logs/{barcode}.guppy.log",
    params:
        barcode = "{barcode}",
        temp_dir = config['results_folder'] + ".temp/guppy",
        alignment_reference = config['alignment_reference_file']
    shell:
        r"""
        # move input files to our temp folder
        # this is required because guppy_aligner wants folders as input
        temp_input={params.temp_dir}/input/{params.barcode}
        temp_output={params.temp_dir}/output/{params.barcode}
        
        # in case any leftover barcode folders are present, we want to remove them, then recreate them
        rm -rf $temp_input; mkdir -p $temp_input
        rm -rf $temp_output        
        cp {input} $temp_input
        
        # run alignment
        guppy_aligner \
        --input_path $temp_input \
        --save_path $temp_output \
        --align_ref {params.alignment_reference} \
        --quiet 
        
        # move files from the temp output to the appropriate folders
        # a temp output allows for better organization
        mv $temp_output/{params.barcode}.nanofilt.sam {output.sam_files}
        mv $temp_output/alignment_summary.txt {output.alignment_summary}
        mv $temp_output/read_processor_log*.log {output.log_file}
        
        # remove our temporary input and output files
        rm -rf $temp_input
        rm -rf $temp_output
        """
rule minimap_aligner:
    input:
        rules.filtering.output[0]
    output:
        config['results_folder'] + "Alignment/minimap/{barcode}.minimap.sam"
    params:
        alignment_reference = config['alignment_reference_file']
    shell:
        r"""
        touch {output}
        
        minimap2 \
        -ax map-ont \
        {params.alignment_reference} \
        {input} > {output}
        """
rule fq2fa:
    input:
        rules.filtering.output[0]
    output:
        temp(config['results_folder'] + "Alignment/vsearch/.{barcode}.temp.fasta")
    shell:
        r"""
        seqkit fq2fa {input} > {output}
        """
rule vsearch_aligner:
    input:
        rules.fq2fa.output[0]
    output:
        config['results_folder'] + "Alignment/vsearch/{barcode}.vsearch.uc"
    params:
        alignment_reference = config['alignment_reference_file']
    shell:
        r"""
        vsearch \
        --usearch_global \
        {input} \
        --db {params.alignment_reference} \
        --id 0 \
        --uc {output} \
        --quiet
        """



rule count_reads_basecall:
    input:
        expand(config['results_folder'] + "Basecall/{fastq_file}.fastq",
               fastq_file=glob_wildcards(config['results_folder'] + "Basecall/{fastq_file}.fastq").fastq_file)
    output:
        config['results_folder'] + "CountReads/count.reads.basecall.csv"
    params:
        process = "basecall"
    script:
        "scripts/CountReads.py"
rule count_reads_barcode:
    input:
        expand(config['results_folder'] + "Barcode/{barcode}.merged.fastq",
               barcode=glob_wildcards(config['results_folder'] + "Barcode/{barcode}.merged.fastq").barcode)
    output:
        config['results_folder'] + "CountReads/count.reads.barcode.csv"
    params:
        process = "barcode"
    script:
        "scripts/CountReads.py"
rule count_reads_cutadapt:
    input:
        expand(config['results_folder'] + "Cutadapt/{barcode}.cutadapt.fastq",
               barcode=glob_wildcards(config['results_folder'] + "Cutadapt/{barcode}.cutadapt.fastq").barcode)
    output:
        config['results_folder'] + "CountReads/count.reads.cutadapt.csv"
    params:
        process = "cutadapt"
    script:
        "scripts/CountReads.py"
rule count_reads_filtering:
    input:
        expand(config['results_folder'] + "NanoFilt/{barcode}.nanofilt.fastq",
               barcode=glob_wildcards(config['results_folder'] + "NanoFilt/{barcode}.nanofilt.fastq").barcode)
    output:
        config['results_folder'] + "CountReads/count.reads.nanofilt.csv"
    params:
        process = "filtering"
    script:
        "scripts/CountReads.py"
rule count_reads_guppy:
    input:
        expand(config['results_folder'] + "Alignment/guppy/alignment_summary/{barcode}.alignment.summary.csv",
               barcode=glob_wildcards(config['results_folder'] + "Alignment/guppy/alignment_summary/{barcode}.alignment.summary.csv").barcode)
    output:
        config['results_folder'] + "CountReads/count.reads.guppy.csv"
    params:
        process = "mapping"
    script:
        "scripts/CountReads.py"



rule plotly_barcode_histogram:
    input:
        rules.count_reads_barcode.output[0]
    output:
        config['results_folder'] + "Visuals/Plotly/Histograms/plotly.barcode.histogram.html"
    params:
        sub_title = "Performed after Merging Files"
    script:
        "scripts/PlotlyHistogram.py"
rule plotly_cutadapt_histogram:
    input:
        rules.count_reads_cutadapt.output[0]
    output:
        config['results_folder'] + "Visuals/Plotly/Histograms/plotly.cutadapt.histogram.html"
    params:
        sub_title = "Performed after Cutadapt"
    script:
        "scripts/PlotlyHistogram.py"
rule plotly_filtering_histogram:
    input:
        rules.count_reads_filtering.output[0]
    output:
        config['results_folder'] + "Visuals/Plotly/Histograms/plotly.filtering.histogram.html"
    params:
        sub_title = "Performed after Filtering"
    script:
        "scripts/PlotlyHistogram.py"
rule plotly_mapping_histogram:
    input:
        rules.count_reads_guppy.output[0]
    output:
        config['results_folder'] + "Visuals/Plotly/Histograms/plotly.mapping.histogram.html"
    params:
        sub_title = "Performed after Mapping"
    script:
        "scripts/PlotlyHistogram.py"
rule plotly_box_whisker_generation:
    input:
        rules.count_reads_barcode.output[0],
        rules.count_reads_cutadapt.output[0],
        rules.count_reads_filtering.output[0],
        rules.count_reads_guppy.output[0]
    output:
        config['results_folder'] + "Visuals/Plotly/plotly.box.whisker.html"
    script:
        "scripts/PlotlyBoxWhisker.py"
