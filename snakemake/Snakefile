import glob
import os
from pathlib import Path

configfile: "config.yaml"

def barcode_numbers(path: str):
    """
    This function will return a list of barcode numbers under the directory passed in
    First, folders will be checked. If no folders exist, file names will be tested
    Args:
        path: The directory that should be searched
    Returns: A list of strings containing directory names
    """
    directories_found = False
    barcode_numbers = set()

    for root, directories, files in os.walk(path):
        for directory in directories:
            if "barcode" in directory or "unclassified" in directory:
                directories_found = True
                barcode_numbers.add(directory)

        # only search for files if directories is false
        if not directories_found:
            for file in files:
                if "barcode" in file or "unclassified" in file:
                    barcode_number = file.split(".")[0]
    return barcode_numbers



def basecall_barcode_merge_files(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = set()  # a set is like a list, but only stores unique values
    for folder in os.listdir(checkpoint_output):
        full_path = os.path.join(checkpoint_output, folder)
        if Path(full_path).is_dir():
            barcodes.add(folder)

    merge_files = [config['results_folder'] + "Barcode/" + barcode + ".merged.fastq" for barcode in barcodes]
    return merge_files

def nanoqc_pre_trim(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "NanoQC/Pre-Trim/{barcode}",
        barcode=barcodes
    )

def trim_reads(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "Trim/{barcode}.trim.fastq",
        barcode=barcodes
    )

def nanoqc_post_trim(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "NanoQC/Post-Trim/{barcode}",
        barcode=barcodes
    )

def NanoFilt(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "NanoFilt/{barcode}.nanofilt.fastq",
        barcode=barcodes
    )

def guppy_aligner(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "Alignment/guppy/sam_files/{barcode}.guppy.sam",
               barcode=barcodes
    )

def minimap_aligner(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "Alignment/minimap/{barcode}.minimap.sam",
        barcode=barcodes
    )

def vsearch_aligner(wildcards):
    checkpoint_output = checkpoints.basecall_barcode.get(**wildcards).output[0]
    barcodes = barcode_numbers(checkpoint_output)
    return expand(
        config['results_folder'] + "Alignment/vsearch/{barcode}.vsearch.uc",
        barcode=barcodes
    )

FAST5_FILES = glob_wildcards(config['results_folder'] + "DataFiles/fast5/{fast5_file}.fast5").fast5_file

rule all:
    input:
        basecall_barcode_merge_files,
        nanoqc_pre_trim,
        trim_reads,
        nanoqc_post_trim,
        NanoFilt,
        guppy_aligner,
        minimap_aligner,
        vsearch_aligner



checkpoint basecall_barcode:
    input:
        config['results_folder'] + "DataFiles/fast5/"
    output:
        directory(config['results_folder'] + ".barcodeTempOutput/")
    params:
        configuration = config['basecall_configuration'],
        barcode_kits = config['barcode_kit'],
        callers = config['num_callers'],
        threads_per_caller = config['num_threads_per_caller']
    conda:
        "envs/pythonEnv.yaml"
    shell:
        "guppy_basecaller "
        "--config {params.configuration} "
        "--input_path {input} "
        "--save_path {output} "
        "--barcode_kits {params.barcode_kits} "
        "--num_callers {params.callers} "
        "--cpu_threads_per_caller {params.threads_per_caller} "
        "--recursive "

        " && "
        "echo BASECALL: {output}"



def merge_files_input(wildcards):
    return glob.glob(config['results_folder'] + f".barcodeTempOutput/{wildcards.barcode}/*.fastq")
rule merge_files:
    input:
        merge_files_input
    output:
        config['results_folder'] + "Barcode/{barcode}.merged.fastq"
    params:
        input_folder = config['results_folder'] + ".barcodeTempOutput",
        save_folder = config['results_folder'] + "Barcode"
    shell:
        r"""
        echo {input}
        for item in {input}; do
            cat $item >> {output}
            #rm $item
        done
        
        # move other files out of .barcodeTempOutput and into the save directory
        # we are only going to move them if they are present
        if [[ -f {params.input_folder}/*.txt ]]; then
            mv {params.input_folder}/*.txt {params.save_folder}/
        fi
        
        if [[ -f {params.input_folder}/*.log ]]; then
            mv {params.input_folder}/*.log {params.save_folder}/
        fi
        
        if [[ -f {params.input_folder}/*.js ]]; then
            mv {params.input_folder}/*.js {params.save_folder}/
        fi
        """



rule NanoQCPreTrim:
    input:
        rules.merge_files.output[0]
    output:
        directory(config['results_folder'] + "NanoQC/Pre-Trim/{barcode}")
    shell:
        r"""
        nanoQC -o {output} {input}
        """


rule trim:
    input:
        rules.merge_files.output[0]
    output:
        config['results_folder'] + "Trim/{barcode}.trim.fastq"
    params:
        three_prime_adapter = config['trim_three_prime_adapter'],
        five_prime_adapter = config['trim_five_prime_adapter'],
        error_rate = config['trim_error_rate']
    shell:
        r"""
        cutadapt \
        --revcomp \
        --quiet \
        --cores 0 \
        --adapter {params.three_prime_adapter} \
        --front {params.five_prime_adapter} \
        --error-rate {params.error_rate} \
        --output {output} \
        {input}
        """



rule NanoQCPostTrim:
    input:
        rules.trim.output[0]
    output:
        directory(config['results_folder'] + "NanoQC/Post-Trim/{barcode}")
    shell:
        r"""
        nanoQC -o {output} {input}
        """



rule NanoFilt:
    input:
        rules.trim.output[0]
    output:
        config['results_folder'] + "NanoFilt/{barcode}.nanofilt.fastq"
    shell:
        r"""
        touch {output}
        NanoFilt {input} > {output}
        """



rule guppy_aligner:
    input:
        rules.NanoFilt.output[0]
    output:
        sam_files = config['results_folder'] + "Alignment/guppy/sam_files/{barcode}.guppy.sam",
    params:
        barcode = "{barcode}",
        alignment_reference = config['alignment_reference_file'],
        guppy_folder = config['results_folder'] + "Alignment/guppy",
        temp_input_folder = config['results_folder'] + ".guppyTempInput/{barcode}",
        log_path = config['results_folder'] + "Alignment/guppy/logs"
    shell:
        r"""
        # guppy_aligner requires a folder as input. We will make that input folder and copy the appropriate file here
        mkdir -p {params.temp_input_folder}
        cp {input} {params.temp_input_folder}
        
        # perform alignment
        guppy_aligner \
        --input_path {params.temp_input_folder} \
        --save_path {params.guppy_folder} \
        --align_ref {params.alignment_reference} \
        --quiet
        
        # move our output to the correct location
        touch {output.sam_files}
        mv {params.guppy_folder}/{params.barcode}.nanofilt.sam {output.sam_files}
        
        
        # remove the temporary input folder as it is no longer needed
        rm -r {params.temp_input_folder}
        
        # we are going to move log files into one directory
        # if any logs are present, continue
        if [[ `ls {params.guppy_folder}/*.log` ]]; then
            
            # create our log folder if we need to move items
            mkdir -p {params.log_path}
            
            # set working directory to get file names
            cd {params.guppy_folder}
            
            # move any logs that are present to the logs folder
            for item in `ls *.log`; do
                touch {params.log_path}/$item
                mv {params.guppy_folder}/$item {params.log_path}/$item
            done
        fi
        """



rule minimap_aligner:
    input:
        rules.NanoFilt.output[0]
    output:
        config['results_folder'] + "Alignment/minimap/{barcode}.minimap.sam"
    params:
        alignment_reference = config['alignment_reference_file']
    shell:
        r"""
        touch {output}
        
        minimap2 \
        -ax map-ont \
        {params.alignment_reference} \
        {input} > {output}
        """



rule fq2fa:
    input:
        rules.NanoFilt.output[0]
    output:
        temp(config['results_folder'] + "Alignment/vsearch/.temp_fasta_{barcode}.fasta")
    shell:
        r"""
        seqkit fq2fa {input} > {output}
        """
rule vsearch_aligner:
    input:
        rules.fq2fa.output[0]
    output:
        config['results_folder'] + "Alignment/vsearch/{barcode}.vsearch.uc"
    params:
        alignment_reference = config['alignment_reference_file']
    shell:
        r"""
        vsearch \
        --usearch_global \
        {input} \
        --db {params.alignment_reference} \
        --id 0 \
        --uc {output} \
        --quiet
        """
