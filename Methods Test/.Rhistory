sum(col_subset(x, 'divergence') <= y) / nrow(x)
}) %>%
set_names(thresholds)
}) %>%
do.call(cbind, .) %>%
cbind(threshold = thresholds) %>%
melt(id.vars=threshold)
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
# geom_point() +
geom_path() +
labs(x='Maximum "Divergence"',
y='Percent Retained Reads',
color='Alignment Method',
main='Sample Reads Mapped to Zymo') +
theme_minimal()
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
# geom_point() +
geom_path() +
geom_vline(aes(xintercept=0.84)) +
geom_vline(aes(xintercept=0.8)) +
labs(x='Maximum "Divergence"',
y='Percent Retained Reads',
color='Alignment Method',
main='Sample Reads Mapped to Zymo') +
theme_minimal()
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
# geom_point() +
geom_path() +
geom_vline(aes(xintercept=0.16)) +
geom_vline(aes(xintercept=0.2))
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
# geom_point() +
geom_path() +
geom_vline(aes(xintercept=0.16)) +
geom_vline(aes(xintercept=0.2)) +
labs(x='Maximum "Divergence"',
y='Percent Retained Reads',
color='Alignment Method',
main='Sample Reads Mapped to Zymo') +
theme_minimal()
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
geom_vline(aes(xintercept=0.16)) +
geom_vline(aes(xintercept=0.2)) +
geom_path() +
labs(x='Maximum "Divergence"',
y='Percent Retained Reads',
color='Alignment Method',
main='Sample Reads Mapped to Zymo') +
theme_minimal()
subset(seq_div, Var2 != 'threshold') %>%
ggplot(aes(x=Var1,
y=value,
color=Var2)) +
geom_vline(aes(xintercept=0.16),
color='gray') +
geom_vline(aes(xintercept=0.2),
color='gray') +
geom_path() +
labs(x='Maximum "Divergence"',
y='Percent Retained Reads',
color='Alignment Method',
main='Sample Reads Mapped to Zymo') +
theme_minimal()
mappers = c('guppy', 'minimap', 'vsearch')
pct_id = 0.90
ss = lapply(mappers, function(x) {
tt = col_subset(primaries, x)
passes = col_subset(tt, 'divergence') <= 1-pct_id
tt = tt[passes, ] %>%
col_subset('ref_spp')
tt = tapply(tt[, 1], tt[, 1], length)
tt = tt/sum(tt)
tt = data.frame(taxa = names(tt),
value = tt)
return(tt)
}) %>%
set_names(mappers)
ss = lapply(mappers, function(x) {
if (nrow(ss[[x]])>0) {
data.frame(method = x,
ss[[x]])
}
}) %>%
do.call(rbind, .)
pltdf = rbind(add_zymo,
ss)
head(ss)
add_zymo = data.frame(method='zymo',
taxa=zymo$taxa,
value=zymo$abundance)
pltdf = rbind(add_zymo,
ss)
title = (100*pct_id) %>%
paste0('% Minimum Identity')
ggplot(pltdf,
aes(x=method,
y=value,
fill=taxa)) +
scale_fill_brewer(palette='Set3') +
# facet_wrap(~variable, nrow=1) +
geom_col() +
labs(fill=NULL,
x='Mapper',
y='Read Proportion',
title=title) +
theme_minimal()
ord_mat = col_subset(primaries, 'ref_spp') %>%
lapply(function(x) tapply(x, x, length))
ord_mat %<>%
names %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(ord_mat[[x]]),
count=ord_mat[[x]])
return(out)
}) %>%
do.call(rbind, .) %>%
dcast(method ~ taxa)
ord_mat[is.na(ord_mat)] = 0.5
rownames(ord_mat) = ord_mat$method
ord_mat$method = NULL
add_zymo = zymo[, 'abundance'] %>%
set_names(zymo[, 'taxa']) %>%
.[colnames(ord_mat)]
ord_mat %<>% rbind(zymo = add_zymo) %>%
sweep(., 1, rowSums(.), '/')
ord_mat[ord_mat==0] = 1E-6
ord_mat = col_subset(primaries, 'ref_spp') %>%
lapply(function(x) tapply(x, x, length))
ord_mat %<>%
names %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(ord_mat[[x]]),
count=ord_mat[[x]])
return(out)
}) %>%
do.call(rbind, .) %>%
dcast(method ~ taxa)
ord_mat = col_subset(primaries, 'ref_spp') %>%
lapply(function(x) tapply(x, x, length))
ord_mat %<>%
names %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(ord_mat[[x]]),
count=ord_mat[[x]])
return(out)
}) %>%
do.call(rbind, .) %>%
dcast(method ~ taxa)
ord_mat[is.na(ord_mat)] = 0.5
rownames(ord_mat) = ord_mat$method
ord_mat$method = NULL
add_zymo = zymo[, 'abundance'] %>%
set_names(zymo[, 'taxa']) %>%
.[colnames(ord_mat)]
ord_mat %<>% rbind(zymo = add_zymo) %>%
sweep(., 1, rowSums(.), '/')
ord_mat[ord_mat==0] = 1E-6
rownames(ord_mat) %<>%
strsplit('_') %>%
sapply(function(x) x[length(x)])
clr = function(x) {
n = length(x)
ll = log(x)
geomean = exp((1/n)*sum(ll))
out = log(x/geomean)
return(out)
}
ord_mat %<>%
apply(1, clr) %>%
t
ord = prcomp(ord_mat)
{
par(mfrow=c(1,2))
plot(ord, main='Scree')
biplot(ord)
par(mfrow=c(1,1))
}
tt = subset(df, type=='sample' & bit_flag_guppy < 256) %>%
col_subset('ref_spp') %>%
lapply(function(x) tapply(x, x, length)) %>%
lapply(function(x) x/sum(x))
tt = names(tt) %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(tt[[x]]),
value=tt[[x]])
return(out)
}) %>%
do.call(rbind, .)
We'll look at what the aligners have found in the samples, when mapping to the reference database.
Accepting any and all matches gives:
```{r}
tt = subset(df, type=='sample' & bit_flag_guppy < 256) %>%
col_subset('ref_spp') %>%
lapply(function(x) tapply(x, x, length)) %>%
lapply(function(x) x/sum(x))
tt = names(tt) %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(tt[[x]]),
value=tt[[x]])
return(out)
}) %>%
do.call(rbind, .)
tt$method %<>%
as.character %>%
strsplit('_') %>%
sapply(extract, 3)
add_zymo = data.frame(
method='zymo',
taxa = zymo$taxa,
value = zymo$abundance
)
tt = subset(df, type=='sample' & bit_flag_guppy < 256) %>%
col_subset('ref_spp') %>%
lapply(function(x) tapply(x, x, length)) %>%
lapply(function(x) x/sum(x))
tt = names(tt) %>%
lapply(function(x) {
out = data.frame(method=x,
taxa=names(tt[[x]]),
value=tt[[x]])
return(out)
}) %>%
do.call(rbind, .)
tt$method %<>%
as.character %>%
strsplit('_') %>%
sapply(extract, 3)
add_zymo = data.frame(
method='zymo',
taxa = zymo$taxa,
value = zymo$abundance
)
pltdf = add_zymo %>%
rbind(tt)
ggplot(pltdf,
aes(x=method,
y=value,
fill=taxa)) +
scale_fill_brewer(palette='Set3') +
# facet_wrap(~variable, nrow=1) +
geom_col() +
labs(fill=NULL,
x='Barcode',
y='Read Proportion') +
theme_minimal()
mappers = c('guppy', 'minimap', 'vsearch')
pct_id = 0.90
ss = lapply(mappers, function(x) {
tt = col_subset(spl, x)
passes = col_subset(tt, 'divergence') <= 1-pct_id
tt = tt[passes, ] %>%
col_subset('ref_spp')
tt = tapply(tt[, 1], tt[, 1], length)
tt = tt/sum(tt)
tt = data.frame(taxa = names(tt),
value = tt)
return(tt)
}) %>%
set_names(mappers)
ss = lapply(mappers, function(x) {
if (nrow(ss[[x]])>0) {
data.frame(method = x,
ss[[x]])
}
}) %>%
do.call(rbind, .)
pltdf = rbind(add_zymo,
ss)
title = (100*pct_id) %>%
paste0('% Minimum Identity')
ggplot(pltdf,
aes(x=method,
y=value,
fill=taxa)) +
scale_fill_brewer(palette='Set3') +
# facet_wrap(~variable, nrow=1) +
geom_col() +
labs(fill=NULL,
x='Mapper',
y='Read Proportion',
title=title) +
theme_minimal()
pct_id = 0.95
ss = lapply(mappers, function(x) {
tt = col_subset(spl, x)
passes = col_subset(tt, 'divergence') <= 1-pct_id
tt = tt[passes, ] %>%
col_subset('ref_spp')
tt = tapply(tt[, 1], tt[, 1], length)
tt = tt/sum(tt)
tt = data.frame(taxa = names(tt),
value = tt)
return(tt)
}) %>%
set_names(mappers)
ss = lapply(mappers, function(x) {
if (nrow(ss[[x]])>0) {
data.frame(method = x,
ss[[x]])
}
}) %>%
do.call(rbind, .)
pltdf = rbind(add_zymo,
ss)
title = (100*pct_id) %>%
paste0('% Minimum Identity')
ggplot(pltdf,
aes(x=method,
y=value,
fill=taxa)) +
scale_fill_brewer(palette='Set3') +
# facet_wrap(~variable, nrow=1) +
geom_col() +
labs(fill=NULL,
x='Mapper',
y='Read Proportion',
title=title) +
theme_minimal()
knitr::opts_chunk$set(message=FALSE,
warning=FALSE,
fig.align='center')
libs = c('pROC', 'lattice', 'latticeExtra', 'here', 'magrittr', 'ggplot2', 'car')
for (i in libs) library(i, character.only=TRUE)
fns = here('Scripts', 'Functions') %>%
list.files(pattern='.R', full.names=TRUE)
for (f in fns) source(f)
path = here('Data', 'Pipeline Results', 'Alignments', 'guppy', 'SAM_Files', 'guppy_aligner_barcode01.sam')
# in_clas = "collated_primary_alignment_data.tsv"
# in_uncl = "collated_unclassified_alignment_data.tsv"
in_sam = file.path('Data', 'Pipeline Results', 'Alignments')
in_guppy = file.path(in_sam, 'guppy', 'SAM_Files')
in_vsearch = file.path(in_sam, 'vsearch', 'UC_Files')
in_minimap = file.path(in_sam, 'minimap', 'csv_results')
in_meta = here('Data', 'MinION CLC Barcodes.csv')
in_zymo = here('Data', 'Zymogen Relative Abundances.csv')
in_path = in_guppy
ext = '.sam'
guppy = here(in_path) %>%
list.files(pattern=ext) %>%
lapply(function(x) {
out = here(in_path, x) %>%
load_sam
out$aligner = strsplit(x, '_') %>%
sapply(extract, 1)
if (grepl('barcode', x)) {
out$barcode = strsplit(x, 'barcode') %>%
sapply(extract, 2) %>%
gsub(ext, '', .)
} else {
out$barcode = 'unclassified'
}
out$filename = x
return(out)
}) %>%
do.call(rbind, .)
in_path = in_minimap
ext = '.csv'
minimap = here(in_path) %>%
list.files(pattern=ext) %>%
lapply(function(x) {
out = here(in_path, x) %>%
load_sam
out$aligner = strsplit(x, '_') %>%
sapply(extract, 1)
if (grepl('barcode', x)) {
out$barcode = strsplit(x, 'barcode') %>%
sapply(extract, 2) %>%
gsub(ext, '', .)
} else {
out$barcode = 'unclassified'
}
out$filename = x
return(out)
}) %>%
do.call(rbind, .)
in_path = in_vsearch
ext = '.uc'
vsearch = here(in_path) %>%
list.files(pattern=ext) %>%
lapply(function(x) {
out = here(in_path, x) %>%
load_uc
out$aligner = strsplit(x, '_') %>%
sapply(extract, 1)
if (grepl('barcode', x)) {
out$barcode = strsplit(x, 'barcode') %>%
sapply(extract, 2) %>%
gsub(ext, '', .)
} else {
out$barcode = 'unclassified'
}
out$filename = x
return(out)
}) %>%
do.call(rbind, .)
meta = read.csv(in_meta, stringsAsFactors=FALSE)
names(meta) %<>% tolower
meta$barcode %<>% gsub('BC', '', .)
zymo = read.csv(in_zymo, stringsAsFactors=FALSE)
names(zymo) %<>% tolower
df_ls = list(guppy=guppy,
minimap=minimap,
vsearch=vsearch)
# Make spp-level assignments
df_ls %<>% lapply(function(x) {
x$ref_spp = strsplit(x$ref_id, '_') %>%
sapply(function(x) paste(x[1:2], collapse='_'))
x$ref_spp = ifelse(is.na(x$ref_id), NA, x$ref_spp)
return(x)
})
# rename most columns
keep_cols = c('seq_id', 'barcode', 'ref_id', 'ref_spp', 'bit_flag', 'seq_length', 'divergence', 'score', 'chimeric')
df_ls = lapply(names(df_ls), function(x) {
tt = df_ls[[x]]
subkeep = keep_cols[keep_cols %in% names(tt)]
tt = tt[subkeep]
names(tt)[-c(1:2)] %<>% paste(x, sep='_')
return(tt)
})
# merge into a single, wide dataframe
df = df_ls[[1]]
for (i in 2:length(df_ls)) {
df %<>% merge(df_ls[[i]], by=c('seq_id', 'barcode'), all=TRUE)
}
# add sample info
df %<>% merge(meta[, c('barcode', 'type')], by='barcode', all=TRUE)
pos = subset(df, type=='positive')
c('seq_length', 'divergence', 'score') %>%
sapply(function(x) grepl(x, names(df))) %>%
apply(1, any) %>%
pos[, .] %>%
pairs(col='#00000022', cex=0.1, main='Positive Controls')
find_disagreement = function(data, value) {
val = grepl(value, names(data)) %>%
data[.]
val_df = apply(val, 1, function(x) any(!is.na(x))) %>%
val[., ]
# convert names to numeric ensuring correct factor levels
lvls = unlist(val_df) %>% unique
val = val_df %>%
as.data.frame %>%
lapply(factor, levels=lvls) %>%
sapply(as.numeric) %>%
cor(use='complete.obs')  # correlate
# calculate disagreement
val = 1-val
return(list(disagreement = val, data = val_df))
}
# extract chimeras
find_disagreement(pos, 'chimeric')
primaries = subset(pos, bit_flag_guppy < 2048)
find_disagreement(primaries, 'ref_id')$disagreement
find_disagreement(primaries, 'ref_spp')$disagreement
#' fuzzy column selection
#'
#' @param data data.frame or matrix
#' @param columns vector of characters to match in `colnames(data)` using `grepl()`.
col_subset = function(data, columns) {
require(magrittr)
is_col = sapply(columns, function(x) grepl(x, names(data))) %>%
apply(1, any)
data %<>% .[is_col]
return(data)
}
disagrees = col_subset(primaries, 'ref_spp') %>%
apply(1, function(x) any(x[-1] != x[1]))
disagrees = primaries[disagrees, ] %>%
col_subset(c('seq_id', 'ref_spp', 'divergence', 'seq_length'))
disagrees
subset(primaries, ref_spp_minimap != ref_spp_vsearch) %>%
col_subset(c('seq_id', 'ref_spp', 'divergence'))
disagree = col_subset(primaries, c('ref_spp')) %>%
apply(1, function(x) {
sapply(x, function(y) any(y != x)) %>%
any
})
c('divergence', 'seq_length') %>%
lapply(function(x) col_subset(primaries, x)) %>%
lapply(pairs, cex=disagree+1, col=adjustcolor(c('blue', 'red'), alpha.f=0.2)[disagree+1])
assigns = col_subset(primaries, c('ref_spp', 'barcode'))
bc_reads = with(assigns, tapply(barcode, barcode, length))
tax_reads = melt(assigns, id.vars='barcode') %>%
aggregate(.[3], ., length)
colnames(tax_reads)[4] = 'count'
split_extract = function(x, split, n) {
require(magrittr)
x %<>%
as.character %>%
strsplit(split) %>%
sapply(extract, n)
return(x)
}
