---
title: "Aligner Comparison"
subtitle: "Created July 13, 2020"
author: "PME"
date: "`r format(Sys.time(), '%d %B, %Y, %H:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding=encoding, output_dir=here::here('Results'))})
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    df_print: paged
    code_folding: hide
  pdf_document: default
  word_document: default
---

```{r set_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, 
                      warning=FALSE,
					  fig.align='center')
```

Selecting an aligner for the MinION metabarcoding pipeline. We're comparing minimap2, guppy_aligner (which is either a custom minimap2 or centrifuge, unclear), and vsearch for now. We want to characterize the tradeoffs between:

1. Sequence retention
2. Reproducibility
3. Accuracy

As we adjust the %identity for kept alignments. 

## Load
```{r}
libs = c('pROC', 'lattice', 'here', 'magrittr', 'data.table')
for (i in libs) library(i, character.only=TRUE)

path = here('Data', 'Pipeline Results', 'Alignments', 'guppy', 'SAM_Files', 'guppy_aligner_barcode01.sam')

#' load_sam to load a sam file from minimap2 and extract useful information from it.
#' currently extracts sequence ID, match, length, 
#'
#' @Parameters
#' @param path: character. full path to .sam file.
#' @param drop_secondary: logical. Skip secondary alignments?
#'
#' @Returns
#' A data.frame with columns:
#' `seq_id`: character. unique sequence identifier.
#' `ref_id`: character. sequence ID of the primary match in the reference database
#' `bit_flag`: integer. bitwise flag. See https://samtools.github.io/hts-specs/SAMv1.pdf and 'Notes'
#' `seq_length`: integer. Length in bp of the aligned sequence.
#' `quality`: integer. Q = -10*log10(prob wrong). Note this is dependent on the database, as well as the sequence.
#' `divergence`: float. per-base divergence of seq from match
#' `score`: integer. smith-waterman alignment score of the entire sequence.
#' `chimeric`: character. sequence ID of a chimeric match. 
#'
#' @Notes
#' Common bitwise flags are: 0 = primary alignment, no problems; 4 = segment unmapped; 
#' 16 = sequence is being reverse-complimented; 256 = secondary alignment; 
#' 2048 = supplementary alignment (i.e. chimeric)


load_sam = function(path, drop_secondary=TRUE) {
  
  sam = readLines(path)
  
  is_header = grepl('@SQ', sam)
  sam %<>% 
    .[!is_header] %>% 
    strsplit('\t') 
  
  if (drop_secondary) {
    is_secondary = sapply(sam, function(x) x[2] == 256)
    sam %<>% .[!is_secondary]
  }
  
  sam %<>%
    lapply(function(x) {
      if (x[2] == 4) { # was not aligned
        out = c(seq_id = x[1],
                ref_id = NA,
                bit_flag = 4,
                seq_length = NA,
                quality = 0,
                divergence = NA,
                score = NA,
                chimeric = NA)
      } else {
        is_chimeric = grepl('SA:Z:', x) %>% 
          any
        out = c(
          seq_id = x[1],
          ref_id = x[3],
          bit_flag = x[2],
          seq_length = nchar(x[10]),
          quality = x[5],
          divergence = x[grepl('dv:f:', x)],
          score = x[grepl('AS:i:', x)],
          # chimeric = x[grepl('SA:A', x)]
          chimeric = ifelse(is_chimeric, x[grepl('SA:Z:', x)], NA)
        )
      }
      return(out)
    }) %>% 
    do.call(rbind, .) %>% 
    as.data.frame
  
  sam$divergence %<>% gsub('dv:f:', '', .)
  sam$score %<>% gsub('AS:i:', '', .)
  sam$chimeric %<>% gsub('SA:Z:', '', .) %>% 
    strsplit(',') %>% 
    sapply(extract, 1)
  sam %<>% type.convert(as.is=TRUE)
  return(sam)
}

QtoPr = function(x) 10^(x/-10)

```

```{r }
# in_clas = "collated_primary_alignment_data.tsv"
# in_uncl = "collated_unclassified_alignment_data.tsv"
in_dir = file.path('Data', 'Pipeline Results', 'Alignments', 'guppy', 'SAM_Files')

ff = here(in_dir) %>% 
  list.files(pattern='*.sam') %>% 
  lapply(function(x) {
    out = here(in_dir, x) %>% 
      load_sam
    out$filename = x
    return(out)
  }) %>% 
  do.call(rbind, .)
ff$aligner = 'guppy'
ff$barcode = gsub('guppy_aligner_', '', ff$filename) %>% 
  gsub('barcode', '', .) %>% 
  gsub('.sam', '', .)
```

```{r fig.height=4, fig.width=8}
dotplot(QtoPr(quality)~barcode, data=subset(ff, bit_flag==0), scales=list(x=list(rot=90)), alpha=0.2, pch=20)
```

```{r fig.height=4, fig.width=8}
dotplot(divergence~barcode, data=subset(ff, bit_flag==0), scales=list(x=list(rot=90)), alpha=0.2, pch=1)
```

```{r fig.height=10, fig.width=7.5}
xyplot(divergence ~ score | barcode, data=subset(ff, bit_flag==0), alpha=0.2, pch=1, type=c('r', 'p'))
```

```{r fig.height=10, fig.width=7.5}
xyplot(divergence ~ QtoPr(quality) | barcode, data=subset(ff, bit_flag==0), alpha=0.2, pch=1, type=c('r', 'p'))
```
