---
title: "Aligner Comparison"
subtitle: "Created July 13, 2020"
author: "PME"
date: "`r format(Sys.time(), '%d %B, %Y, %H:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding=encoding, output_dir=here::here('Results'))})
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    df_print: paged
    code_folding: hide
  pdf_document: default
  word_document: default
---

```{r set_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, 
                      warning=FALSE,
					  fig.align='center')
```

Selecting an aligner for the MinION metabarcoding pipeline. We're comparing minimap2, guppy_aligner (which is either a custom minimap2 or centrifuge, unclear), and vsearch for now. We want to characterize the tradeoffs between:

1. Sequence retention
2. Reproducibility
3. Accuracy

As we adjust the %identity for kept alignments. 

## Load
```{r}
libs = c('pROC', 'lattice', 'latticeExtra', 'here', 'magrittr', 'data.table')
for (i in libs) library(i, character.only=TRUE)

fns = here('Scripts', 'Functions') %>% 
  list.files(pattern='.R', full.names=TRUE)
for (f in fns) source(f)

path = here('Data', 'Pipeline Results', 'Alignments', 'guppy', 'SAM_Files', 'guppy_aligner_barcode01.sam')

```

```{r }
# in_clas = "collated_primary_alignment_data.tsv"
# in_uncl = "collated_unclassified_alignment_data.tsv"
in_sam = file.path('Data', 'Pipeline Results', 'Alignments')
in_guppy = file.path(in_sam, 'guppy', 'SAM_Files')
in_minimap = file.path(in_sam, 'minimap', 'csv_results')
in_meta = here('Data', 'MinION CLC Barcodes.csv')

in_path = in_guppy
ext = '.sam'
guppy = here(in_path) %>% 
  list.files(pattern=ext) %>% 
  lapply(function(x) {
    out = here(in_path, x) %>% 
      load_sam
    out$aligner = strsplit(x, '_') %>% 
      sapply(extract, 1)
    out$barcode = strsplit(x, '_barcode') %>% 
      sapply(extract, 2) %>% 
      gsub(ext, '', .) %>% 
      sapply(function(y) ifelse(is.na(y), 'Unknown', y))
    out$filename = x
    return(out)
  }) %>% 
  do.call(rbind, .)

in_path = in_minimap
ext = '.csv'
minimap = here(in_path) %>% 
  list.files(pattern=ext) #%>% 
  lapply(function(x) {
    out = here(in_path, x) %>% 
      load_sam
    out$aligner = strsplit(x, '_') %>% 
      sapply(extract, 1)
    out$barcode = strsplit(x, '_barcode') %>% 
      sapply(extract, 2) %>% 
      gsub(ext, '', .) %>% 
      sapply(function(y) ifelse(is.na(y), 'Unknown', y))
    out$filename = x
    return(out)
  }) %>% 
  do.call(rbind, .)

minimap = here(in_minimap) %>% 
  list.files(pattern='*.csv') %>% 
  lapply(function(x) {
    out = here(in_minimap, x) %>% 
      load_sam
    out$aligner = strsplit(x, '_') %>% 
      sapply(extract, 1)
    out$barcode = strsplit(x, '_barcode') %>% 
      sapply(extract, 2) %>% 
      gsub('.sam', '', .) %>% 
      sapply(function(y) ifelse(is.na(y), 'Unknown', y))
    out$filename = x
    return(out)
  }) %>% 
  do.call(rbind, .)

meta = read.csv(in_meta, stringsAsFactors=FALSE)
meta$BARCODE %<>% gsub('BC', '', .)

df = merge(df, meta[, c('BARCODE', 'TYPE')], by.x='barcode', by.y='BARCODE', all.x=TRUE)
pos = subset(df, df$TYPE == 'positive')
```

```{r fig.height=4, fig.width=8}
densityplot(~QtoPr(quality) | barcode, data=pos, group=bit_flag, auto.key=list(columns=3), scales=list(x=list(rot=90, limits=c(-0.1,1.1))), alpha=0.5, pch=20)
```

```{r fig.height=4, fig.width=8}
dotplot(divergence~barcode, data=subset(ff), group=bit_flag, auto.key=list(columns=3), scales=list(x=list(rot=90)), alpha=0.2, pch=1)
```

```{r fig.height=10, fig.width=7.5}
xyplot(divergence ~ score | barcode, group=bit_flag, data=subset(ff), auto.key=list(columns=3), alpha=0.2, pch=1)
```
```{r fig.height=5, fig.width=8}
barchart(log2(summary(as.factor(ff$barcode))))
barchart(tapply(ff$seq_length, as.factor(ff$barcode), mean, na.rm=TRUE))
dotplot(score ~ barcode, data=subset(ff, bit_flag==0), alpha=0.2, pch=1)
```

```{r fig.height=5, fig.width=8}
pltdf = subset(ff, bit_flag==0 & barcode %in% c(56, 60))
pltdf$score_ratio = with(pltdf, score / seq_length)
pr = c(0.001, 0.01, 0.05, 0.1, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999)

val = 'score_ratio'
plt_data = pltdf[, val]
densityplot(~plt_data, xlab=val, alpha=0.5, pch=1, scales=list(y='free'), main=paste(100*pr, collapse='%, ')) +
              layer(panel.abline(v=quantile(plt_data, probs=pr)))
```
```{r}
pltdf = subset(ff, bit_flag==0 & barcode %in% c(56, 60))
pltdf$score_ratio = with(pltdf, score / seq_length)
pr = c(0.001, 0.01, 0.05, 0.1, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999)

val = 'score'
plt_data = pltdf[, val]
densityplot(~plt_data, xlab=val, alpha=0.5, pch=1, scales=list(y='free'), main=paste(100*pr, collapse='%, ')) +
              layer(panel.abline(v=quantile(plt_data, probs=pr)))
```

```{r fig.height=5, fig.width=8}
pltdf = subset(ff, bit_flag==0 & !(barcode %in% c(56, 60)))
pltdf$score_ratio = with(pltdf, score / seq_length)
pr = c(0.001, 0.01, 0.05, 0.1, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999)

val = 'score_ratio'
plt_data = pltdf[, val]
densityplot(~plt_data, xlab=val, alpha=0.5, pch=1, scales=list(y='free'), main=paste(100*pr, collapse='%, ')) +
              layer(panel.abline(v=quantile(plt_data, probs=pr)))
```

```{r}
plt_data = pltdf$divergence
densityplot(~plt_data, alpha=0.5, pch=1, scales=list(y='free'), main=paste(pr, collapse='%, ')) +
              layer(panel.abline(v=quantile(plt_data, probs=pr)))

```

```{r}
summary(factor(sff$quality))/nrow(sff)


subset(ff, bit_flag==0 & barcode %in% c(56, 60)) %>% 
  extract(, 'score') %>% 
  quantile(probs=c(0.001, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999))
```

